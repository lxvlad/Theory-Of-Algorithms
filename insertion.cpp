#include <iostream>
#include <ctime>

void Initialize(int arr[], size_t size);
void Show(const int arr[], size_t size);

template <typename T>
void InsertionSort(T arr[], size_t size);

int main()
{
    srand(static_cast<unsigned>(time(nullptr)));

    const int SIZE = 5;
    int arr[SIZE];

    Initialize(arr, SIZE);
    Show(arr, SIZE);

    // Sorting
    InsertionSort(arr, SIZE);
    
    Show(arr, SIZE);
    


    return 0;
}

void Initialize(int arr[], size_t size)
{
    for (size_t i = 0; i < size; i++)
    {
        arr[i] = rand() % 100;
    }
}

void Show(const int arr[], size_t size)
{
    for (size_t i = 0; i < size; i++)
    {
        std::cout << arr[i] << " ";
    }
    std::cout << std::endl;
}

template <typename T>
void InsertionSort(T arr[], size_t size)
{
    // Точна складність:
    // Зовнішній цикл виконується n-1 разів, де n - кількість елементів у масиві.
    // Внутрішній цикл для кожного елемента може виконувати до i порівнянь, де i - індекс елемента.
    // Таким чином, для кожного елемента на i-ій позиції в масиві внутрішній цикл виконується до i разів.
    // В найгіршому випадку (коли масив відсортований у зворотному порядку), кількість порівнянь:
    // 1 + 2 + 3 + ... + (n-1) = (n-1) * n / 2.
    // Отже, точна складність алгоритму в найгіршому випадку O(n^2).

    // Асимптотична складність:
    // У найгіршому випадку, коли кожен елемент потрібно переміщати до початку масиву,
    // кількість порівнянь та операцій переміщення дорівнює O(n^2).
    // Тому асимптотична складність алгоритму — O(n^2) для найгіршого випадку.
    // У кращому випадку, коли масив вже відсортований, складність буде O(n),
    // оскільки внутрішній цикл лише перевіряє умови без переміщення елементів.

    // Проходимо по елементах масиву, починаючи з другого (індекс 1)
    for (size_t i = 1; i < size; i++)
    {
        // Зберігаємо поточне значення, яке потрібно вставити у відсортовану частину
        T key = arr[i];

        // j — індекс для проходу по відсортованій частині масиву
        int j;

        /// Внутрішній цикл переміщає елементи, більші за key
        // в праву сторону, поки не знайде правильну позицію для key
        for (j = i - 1; j >= 0 && arr[j] > key; j--)
        {
            arr[j + 1] = arr[j];
        }

        // Вставляємо елемент key на правильну позицію
        arr[j + 1] = key;
    }
}

